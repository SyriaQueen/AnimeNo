================================================================================
     ğŸ¯ ANIME DETECTOR - Screen Overlay Edition (ÙƒØ§Ù…Ù„ ÙˆÙ†Ù‡Ø§Ø¦ÙŠ)
================================================================================

ØªØ·Ø¨ÙŠÙ‚ overlay ÙŠØ¹Ù…Ù„ ÙÙˆÙ‚ Ø§Ù„Ø´Ø§Ø´Ø© ÙˆÙŠÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ ÙÙŠ Ø£ÙŠ ØªØ·Ø¨ÙŠÙ‚!

Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª:
âœ… ÙŠØ¹Ù…Ù„ ÙÙˆÙ‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª
âœ… ÙŠÙ„ØªÙ‚Ø· Ù„Ù‚Ø·Ø§Øª Ø§Ù„Ø´Ø§Ø´Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
âœ… ÙŠÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ ÙˆÙŠØ¹ØªÙ…Ù‡ ÙÙˆØ±Ø§Ù‹
âœ… Ø²Ø± Ø¹Ø§Ø¦Ù… Ù„Ù„ØªØ­ÙƒÙ… (ØªØ´ØºÙŠÙ„/Ø¥ÙŠÙ‚Ø§Ù)
âœ… Ù…Ø­Ø³Ù‘Ù† Ù„Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ø°Ø§ÙƒØ±Ø©
âœ… Ù„Ø§ ÙŠØ­ØªØ§Ø¬ ÙƒØ§Ù…ÙŠØ±Ø§

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/AndroidManifest.xml
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- ØµÙ„Ø§Ø­ÙŠØ§Øª Screen Overlay -->
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MEDIA_PROJECTION" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/Theme.AnimeDetector"
        tools:targetApi="31">
        
        <!-- Main Activity -->
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:screenOrientation="portrait">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- Overlay Service -->
        <service
            android:name=".OverlayService"
            android:enabled="true"
            android:exported="false"
            android:foregroundServiceType="mediaProjection" />
        
    </application>

</manifest>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/java/com/animedetector/MainActivity.java
================================================================================

package com.animedetector;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.media.projection.MediaProjectionManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.provider.Settings;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import androidx.activity.result.ActivityResultLauncher;
import androidx.activity.result.contract.ActivityResultContracts;
import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {
    private static final int SCREEN_CAPTURE_REQUEST_CODE = 100;
    
    private Button btnStart;
    private Button btnStop;
    private TextView tvStatus;
    
    private ActivityResultLauncher<Intent> screenCaptureLauncher;
    private ActivityResultLauncher<Intent> overlayPermissionLauncher;
    
    private boolean hasOverlayPermission = false;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        btnStart = findViewById(R.id.btnStart);
        btnStop = findViewById(R.id.btnStop);
        tvStatus = findViewById(R.id.tvStatus);
        
        // ØªÙ‡ÙŠØ¦Ø© launchers
        initLaunchers();
        
        // Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
        btnStart.setOnClickListener(v -> checkPermissionsAndStart());
        btnStop.setOnClickListener(v -> stopService());
        
        updateUI();
    }
    
    private void initLaunchers() {
        // Screen capture permission
        screenCaptureLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (result.getResultCode() == Activity.RESULT_OK) {
                    Intent data = result.getData();
                    startOverlayService(data);
                } else {
                    Toast.makeText(this, "ÙŠØ¬Ø¨ Ù…Ù†Ø­ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„Ø´Ø§Ø´Ø©", 
                        Toast.LENGTH_LONG).show();
                }
            }
        );
        
        // Overlay permission
        overlayPermissionLauncher = registerForActivityResult(
            new ActivityResultContracts.StartActivityForResult(),
            result -> {
                if (Settings.canDrawOverlays(this)) {
                    hasOverlayPermission = true;
                    requestScreenCapture();
                } else {
                    Toast.makeText(this, "ÙŠØ¬Ø¨ Ù…Ù†Ø­ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø¹Ø±Ø¶ ÙÙˆÙ‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª", 
                        Toast.LENGTH_LONG).show();
                }
            }
        );
    }
    
    private void checkPermissionsAndStart() {
        // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Overlay
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if (!Settings.canDrawOverlays(this)) {
                requestOverlayPermission();
                return;
            }
        }
        
        hasOverlayPermission = true;
        requestScreenCapture();
    }
    
    private void requestOverlayPermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            Intent intent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,
                Uri.parse("package:" + getPackageName()));
            overlayPermissionLauncher.launch(intent);
        }
    }
    
    private void requestScreenCapture() {
        MediaProjectionManager projectionManager = 
            (MediaProjectionManager) getSystemService(Context.MEDIA_PROJECTION_SERVICE);
        
        Intent captureIntent = projectionManager.createScreenCaptureIntent();
        screenCaptureLauncher.launch(captureIntent);
    }
    
    private void startOverlayService(Intent data) {
        Intent serviceIntent = new Intent(this, OverlayService.class);
        serviceIntent.putExtra("resultCode", Activity.RESULT_OK);
        serviceIntent.putExtra("data", data);
        
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(serviceIntent);
        } else {
            startService(serviceIntent);
        }
        
        updateUI();
        Toast.makeText(this, "âœ… Ø¨Ø¯Ø£ ÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©", Toast.LENGTH_SHORT).show();
    }
    
    private void stopService() {
        Intent serviceIntent = new Intent(this, OverlayService.class);
        stopService(serviceIntent);
        updateUI();
        Toast.makeText(this, "â¸ï¸ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ´Ù", Toast.LENGTH_SHORT).show();
    }
    
    private void updateUI() {
        boolean isRunning = OverlayService.isRunning();
        btnStart.setEnabled(!isRunning);
        btnStop.setEnabled(isRunning);
        tvStatus.setText(isRunning ? "ğŸŸ¢ ÙŠØ¹Ù…Ù„ - ÙŠÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ" : "âšª Ù…ØªÙˆÙ‚Ù");
    }
    
    @Override
    protected void onResume() {
        super.onResume();
        updateUI();
    }
}

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/java/com/animedetector/OverlayService.java
================================================================================

package com.animedetector;

import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.hardware.display.DisplayManager;
import android.hardware.display.VirtualDisplay;
import android.media.Image;
import android.media.ImageReader;
import android.media.projection.MediaProjection;
import android.media.projection.MediaProjectionManager;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.WindowManager;
import android.widget.ImageView;

import androidx.core.app.NotificationCompat;

import java.nio.ByteBuffer;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class OverlayService extends Service {
    private static final String TAG = "OverlayService";
    private static final String CHANNEL_ID = "AnimeDetectorChannel";
    private static final int NOTIFICATION_ID = 1;
    private static final int FRAME_SKIP = 3; // Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„ 4 Ø¥Ø·Ø§Ø±Ø§Øª
    
    private static final AtomicBoolean isServiceRunning = new AtomicBoolean(false);
    
    // Media Projection
    private MediaProjectionManager projectionManager;
    private MediaProjection mediaProjection;
    private VirtualDisplay virtualDisplay;
    private ImageReader imageReader;
    
    // Overlay View
    private WindowManager windowManager;
    private View overlayView;
    private ImageView overlayImageView;
    
    // Detection
    private OptimizedAnimeDetector detector;
    private DetectionSmoother smoother;
    
    // Threading
    private HandlerThread captureThread;
    private Handler captureHandler;
    private HandlerThread detectionThread;
    private Handler detectionHandler;
    
    // Display metrics
    private int screenWidth;
    private int screenHeight;
    private int screenDensity;
    
    // Control
    private final AtomicBoolean isProcessing = new AtomicBoolean(false);
    private int frameCounter = 0;
    
    // Overlay bitmap
    private Bitmap overlayBitmap;
    private final Object overlayLock = new Object();
    
    public static boolean isRunning() {
        return isServiceRunning.get();
    }
    
    @Override
    public void onCreate() {
        super.onCreate();
        
        Log.i(TAG, "Service created");
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…ÙƒÙˆÙ†Ø§Øª
        windowManager = (WindowManager) getSystemService(WINDOW_SERVICE);
        projectionManager = (MediaProjectionManager) getSystemService(MEDIA_PROJECTION_SERVICE);
        
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£Ø¨Ø¹Ø§Ø¯ Ø§Ù„Ø´Ø§Ø´Ø©
        DisplayMetrics metrics = new DisplayMetrics();
        windowManager.getDefaultDisplay().getRealMetrics(metrics);
        screenWidth = metrics.widthPixels;
        screenHeight = metrics.heightPixels;
        screenDensity = metrics.densityDpi;
        
        // ØªÙ‡ÙŠØ¦Ø© threads
        captureThread = new HandlerThread("CaptureThread");
        captureThread.start();
        captureHandler = new Handler(captureThread.getLooper());
        
        detectionThread = new HandlerThread("DetectionThread");
        detectionThread.start();
        detectionHandler = new Handler(detectionThread.getLooper());
        
        // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ÙƒØ§Ø´Ù
        try {
            detector = new OptimizedAnimeDetector(this);
            smoother = new DetectionSmoother(5);
        } catch (Exception e) {
            Log.e(TAG, "Failed to initialize detector", e);
            stopSelf();
            return;
        }
        
        isServiceRunning.set(true);
    }
    
    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (intent == null) {
            stopSelf();
            return START_NOT_STICKY;
        }
        
        // Ø¨Ø¯Ø¡ foreground service
        createNotificationChannel();
        Notification notification = createNotification();
        startForeground(NOTIFICATION_ID, notification);
        
        // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†ØªÙŠØ¬Ø© screen capture
        int resultCode = intent.getIntExtra("resultCode", 0);
        Intent data = intent.getParcelableExtra("data");
        
        if (resultCode == 0 || data == null) {
            Log.e(TAG, "Invalid screen capture data");
            stopSelf();
            return START_NOT_STICKY;
        }
        
        // Ø¨Ø¯Ø¡ screen capture
        startScreenCapture(resultCode, data);
        
        // Ø¥Ù†Ø´Ø§Ø¡ overlay view
        createOverlayView();
        
        return START_STICKY;
    }
    
    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                CHANNEL_ID,
                "Anime Detector",
                NotificationManager.IMPORTANCE_LOW
            );
            channel.setDescription("ÙƒØ§Ø´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ ÙŠØ¹Ù…Ù„");
            
            NotificationManager manager = getSystemService(NotificationManager.class);
            manager.createNotificationChannel(channel);
        }
    }
    
    private Notification createNotification() {
        Intent notificationIntent = new Intent(this, MainActivity.class);
        PendingIntent pendingIntent = PendingIntent.getActivity(
            this, 0, notificationIntent,
            PendingIntent.FLAG_IMMUTABLE
        );
        
        return new NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Anime Detector")
            .setContentText("ğŸ¯ ÙŠÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©")
            .setSmallIcon(android.R.drawable.ic_menu_view)
            .setContentIntent(pendingIntent)
            .setOngoing(true)
            .build();
    }
    
    private void startScreenCapture(int resultCode, Intent data) {
        // Ø¥Ù†Ø´Ø§Ø¡ ImageReader
        imageReader = ImageReader.newInstance(
            screenWidth, screenHeight,
            PixelFormat.RGBA_8888, 2
        );
        
        imageReader.setOnImageAvailableListener(reader -> {
            // Frame skipping
            if (++frameCounter % (FRAME_SKIP + 1) != 0) {
                Image image = reader.acquireLatestImage();
                if (image != null) image.close();
                return;
            }
            
            Image image = reader.acquireLatestImage();
            if (image != null) {
                processImage(image);
            }
        }, captureHandler);
        
        // Ø¥Ù†Ø´Ø§Ø¡ MediaProjection
        mediaProjection = projectionManager.getMediaProjection(resultCode, data);
        
        // Ø¥Ù†Ø´Ø§Ø¡ VirtualDisplay
        virtualDisplay = mediaProjection.createVirtualDisplay(
            "AnimeDetector",
            screenWidth, screenHeight, screenDensity,
            DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,
            imageReader.getSurface(),
            null, captureHandler
        );
        
        Log.i(TAG, "Screen capture started");
    }
    
    private void createOverlayView() {
        LayoutInflater inflater = LayoutInflater.from(this);
        overlayView = inflater.inflate(R.layout.overlay_layout, null);
        overlayImageView = overlayView.findViewById(R.id.overlayImage);
        
        int layoutType;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            layoutType = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;
        } else {
            layoutType = WindowManager.LayoutParams.TYPE_PHONE;
        }
        
        WindowManager.LayoutParams params = new WindowManager.LayoutParams(
            WindowManager.LayoutParams.MATCH_PARENT,
            WindowManager.LayoutParams.MATCH_PARENT,
            layoutType,
            WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE |
            WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE |
            WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN,
            PixelFormat.TRANSLUCENT
        );
        
        params.gravity = Gravity.TOP | Gravity.START;
        
        windowManager.addView(overlayView, params);
        
        Log.i(TAG, "Overlay view created");
    }
    
    private void processImage(Image image) {
        if (!isProcessing.compareAndSet(false, true)) {
            image.close();
            return;
        }
        
        detectionHandler.post(() -> {
            try {
                // ØªØ­ÙˆÙŠÙ„ Image Ø¥Ù„Ù‰ Bitmap
                Bitmap bitmap = imageToBitmap(image);
                
                if (bitmap != null) {
                    // Ø§Ù„ÙƒØ´Ù
                    OptimizedAnimeDetector.DetectionResult result = 
                        detector.detect(bitmap);
                    
                    // Ø§Ù„ØªÙ†Ø¹ÙŠÙ…
                    if (smoother != null) {
                        result = smoother.smooth(result);
                    }
                    
                    // ØªØ­Ø¯ÙŠØ« overlay
                    updateOverlay(result, bitmap.getWidth(), bitmap.getHeight());
                    
                    bitmap.recycle();
                }
                
            } catch (Exception e) {
                Log.e(TAG, "Error processing image", e);
            } finally {
                image.close();
                isProcessing.set(false);
            }
        });
    }
    
    private Bitmap imageToBitmap(Image image) {
        Image.Plane[] planes = image.getPlanes();
        ByteBuffer buffer = planes[0].getBuffer();
        int pixelStride = planes[0].getPixelStride();
        int rowStride = planes[0].getRowStride();
        int rowPadding = rowStride - pixelStride * screenWidth;
        
        Bitmap bitmap = Bitmap.createBitmap(
            screenWidth + rowPadding / pixelStride,
            screenHeight,
            Bitmap.Config.ARGB_8888
        );
        
        bitmap.copyPixelsFromBuffer(buffer);
        
        // Ù‚Øµ Ø§Ù„Ù€ padding Ø¥Ø°Ø§ ÙˆÙØ¬Ø¯
        if (rowPadding != 0) {
            Bitmap croppedBitmap = Bitmap.createBitmap(
                bitmap, 0, 0, screenWidth, screenHeight
            );
            bitmap.recycle();
            return croppedBitmap;
        }
        
        return bitmap;
    }
    
    private void updateOverlay(OptimizedAnimeDetector.DetectionResult result, 
                               int width, int height) {
        synchronized (overlayLock) {
            // Ø¥Ù†Ø´Ø§Ø¡ bitmap Ù„Ù„Ù€ overlay
            if (overlayBitmap == null || 
                overlayBitmap.getWidth() != width || 
                overlayBitmap.getHeight() != height ||
                overlayBitmap.isRecycled()) {
                
                if (overlayBitmap != null && !overlayBitmap.isRecycled()) {
                    overlayBitmap.recycle();
                }
                
                overlayBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
            }
            
            Canvas canvas = new Canvas(overlayBitmap);
            canvas.drawColor(Color.TRANSPARENT);
            
            if (!result.detections.isEmpty()) {
                Paint paint = new Paint();
                paint.setColor(Color.argb(220, 0, 0, 0));
                paint.setStyle(Paint.Style.FILL);
                
                for (OptimizedAnimeDetector.Detection det : result.detections) {
                    float margin = Math.min(det.width, det.height) * 0.05f;
                    canvas.drawRect(
                        det.x1 - margin, det.y1 - margin,
                        det.x2 + margin, det.y2 + margin,
                        paint
                    );
                }
            }
            
            // ØªØ­Ø¯ÙŠØ« UI
            new Handler(getMainLooper()).post(() -> {
                if (overlayImageView != null) {
                    overlayImageView.setImageBitmap(overlayBitmap);
                }
            });
        }
    }
    
    @Override
    public void onDestroy() {
        isServiceRunning.set(false);
        
        // Ø¥ÙŠÙ‚Ø§Ù screen capture
        if (virtualDisplay != null) {
            virtualDisplay.release();
        }
        
        if (mediaProjection != null) {
            mediaProjection.stop();
        }
        
        if (imageReader != null) {
            imageReader.close();
        }
        
        // Ø¥Ø²Ø§Ù„Ø© overlay
        if (overlayView != null && windowManager != null) {
            windowManager.removeView(overlayView);
        }
        
        // ØªÙ†Ø¸ÙŠÙ resources
        synchronized (overlayLock) {
            if (overlayBitmap != null && !overlayBitmap.isRecycled()) {
                overlayBitmap.recycle();
            }
        }
        
        if (detector != null) {
            detector.close();
        }
        
        if (smoother != null) {
            smoother.clear();
        }
        
        // Ø¥ÙŠÙ‚Ø§Ù threads
        if (captureThread != null) {
            captureThread.quitSafely();
        }
        
        if (detectionThread != null) {
            detectionThread.quitSafely();
        }
        
        super.onDestroy();
        
        Log.i(TAG, "Service destroyed");
    }
    
    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }
}

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/java/com/animedetector/OptimizedAnimeDetector.java
================================================================================

package com.animedetector;

import android.content.Context;
import android.graphics.Bitmap;
import android.util.Log;

import ai.onnxruntime.OnnxTensor;
import ai.onnxruntime.OrtEnvironment;
import ai.onnxruntime.OrtSession;
import ai.onnxruntime.providers.NNAPIFlags;

import java.io.InputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EnumSet;
import java.util.List;

public class OptimizedAnimeDetector {
    private static final String TAG = "AnimeDetector";
    private static final String MODEL_NAME = "anime_detector.onnx";
    private static final int INPUT_SIZE = 640;
    private static final float CONF_THRESHOLD = 0.25f;
    private static final float IOU_THRESHOLD = 0.45f;
    private static final int MAX_DETECTIONS = 100;
    
    private final ByteBuffer directBuffer;
    private final FloatBuffer floatView;
    private final Object bufferLock = new Object();
    
    private final float[] precomputedAreas;
    private final boolean[] suppressedFlags;
    
    private final OrtEnvironment env;
    private final OrtSession session;
    private final String inputName;
    
    private volatile float adaptiveConfThreshold = CONF_THRESHOLD;
    
    public static class Detection {
        public final float x1, y1, x2, y2;
        public final float width, height;
        public final float confidence;
        public final int classId;
        public final float centerX, centerY;
        public final float area;
        
        public Detection(float x1, float y1, float x2, float y2, float conf, int cls) {
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
            this.width = x2 - x1;
            this.height = y2 - y1;
            this.confidence = conf;
            this.classId = cls;
            this.centerX = (x1 + x2) * 0.5f;
            this.centerY = (y1 + y2) * 0.5f;
            this.area = width * height;
        }
    }
    
    public static class DetectionResult {
        public final List<Detection> detections;
        public final float avgConfidence;
        public final int imageWidth;
        public final int imageHeight;
        
        public DetectionResult(List<Detection> detections, int width, int height) {
            this.detections = detections;
            this.imageWidth = width;
            this.imageHeight = height;
            this.avgConfidence = calculateAvgConfidence(detections);
        }
        
        private float calculateAvgConfidence(List<Detection> detections) {
            if (detections.isEmpty()) return 0f;
            float sum = 0f;
            for (Detection d : detections) sum += d.confidence;
            return sum / detections.size();
        }
    }
    
    public OptimizedAnimeDetector(Context context) {
        try {
            int cores = Runtime.getRuntime().availableProcessors();
            int onnxThreads = Math.max(1, cores - 2);
            
            env = OrtEnvironment.getEnvironment();
            
            InputStream modelStream = context.getAssets().open(MODEL_NAME);
            byte[] modelBytes = new byte[modelStream.available()];
            modelStream.read(modelBytes);
            modelStream.close();
            
            OrtSession.SessionOptions options = new OrtSession.SessionOptions();
            
            try {
                options.addNnapi(EnumSet.of(NNAPIFlags.USE_FP16));
                Log.i(TAG, "NNAPI enabled");
            } catch (Exception e) {
                Log.w(TAG, "NNAPI not available");
            }
            
            options.setIntraOpNumThreads(onnxThreads);
            options.setInterOpNumThreads(1);
            options.setOptimizationLevel(OrtSession.SessionOptions.OptLevel.ALL_OPT);
            
            if (cores >= 6) {
                options.setExecutionMode(OrtSession.SessionOptions.ExecutionMode.PARALLEL);
            } else {
                options.setExecutionMode(OrtSession.SessionOptions.ExecutionMode.SEQUENTIAL);
            }
            
            session = env.createSession(modelBytes, options);
            inputName = session.getInputNames().iterator().next();
            
            int bufferSize = 3 * INPUT_SIZE * INPUT_SIZE * Float.BYTES;
            directBuffer = ByteBuffer.allocateDirect(bufferSize)
                .order(ByteOrder.nativeOrder());
            floatView = directBuffer.asFloatBuffer();
            
            precomputedAreas = new float[MAX_DETECTIONS];
            suppressedFlags = new boolean[MAX_DETECTIONS];
            
            Log.i(TAG, "Detector initialized");
            
        } catch (Exception e) {
            Log.e(TAG, "Failed to initialize", e);
            throw new RuntimeException("Cannot load model", e);
        }
    }
    
    public DetectionResult detect(Bitmap bitmap) {
        try {
            preprocessBitmap(bitmap);
            
            float[][][] output;
            synchronized (bufferLock) {
                floatView.position(0);
                
                long[] shape = {1, 3, INPUT_SIZE, INPUT_SIZE};
                OnnxTensor inputTensor = OnnxTensor.createTensor(env, floatView, shape);
                
                OrtSession.Result result = session.run(
                    Collections.singletonMap(inputName, inputTensor)
                );
                
                output = (float[][][]) result.get(0).getValue();
                
                result.close();
                inputTensor.close();
            }
            
            List<Detection> detections = postprocess(output, bitmap.getWidth(), bitmap.getHeight());
            
            updateAdaptiveThreshold(detections);
            
            return new DetectionResult(detections, bitmap.getWidth(), bitmap.getHeight());
            
        } catch (Exception e) {
            Log.e(TAG, "Detection error", e);
            return new DetectionResult(new ArrayList<>(), bitmap.getWidth(), bitmap.getHeight());
        }
    }
    
    private void preprocessBitmap(Bitmap bitmap) {
        synchronized (bufferLock) {
            floatView.clear();
            
            Bitmap resized = Bitmap.createScaledBitmap(bitmap, INPUT_SIZE, INPUT_SIZE, true);
            
            int[] pixels = new int[INPUT_SIZE * INPUT_SIZE];
            resized.getPixels(pixels, 0, INPUT_SIZE, 0, 0, INPUT_SIZE, INPUT_SIZE);
            
            final float inv255 = 1.0f / 255.0f;
            
            for (int c = 0; c < 3; c++) {
                for (int h = 0; h < INPUT_SIZE; h++) {
                    for (int w = 0; w < INPUT_SIZE; w++) {
                        int pixel = pixels[h * INPUT_SIZE + w];
                        float value;
                        
                        if (c == 0) value = ((pixel >> 16) & 0xFF) * inv255;
                        else if (c == 1) value = ((pixel >> 8) & 0xFF) * inv255;
                        else value = (pixel & 0xFF) * inv255;
                        
                        floatView.put(value);
                    }
                }
            }
            
            floatView.flip();
            resized.recycle();
        }
    }
    
    private List<Detection> postprocess(float[][][] output, int originalWidth, int originalHeight) {
        int numPredictions = output[0][0].length;
        
        List<Detection> allDetections = new ArrayList<>();
        
        float scaleX = (float) originalWidth / INPUT_SIZE;
        float scaleY = (float) originalHeight / INPUT_SIZE;
        
        for (int i = 0; i < numPredictions && allDetections.size() < MAX_DETECTIONS; i++) {
            float centerX = output[0][0][i];
            float centerY = output[0][1][i];
            float width = output[0][2][i];
            float height = output[0][3][i];
            
            float conf = output[0][4][i];
            
            if (conf <= adaptiveConfThreshold) continue;
            
            float x1 = (centerX - width * 0.5f) * scaleX;
            float y1 = (centerY - height * 0.5f) * scaleY;
            float x2 = (centerX + width * 0.5f) * scaleX;
            float y2 = (centerY + height * 0.5f) * scaleY;
            
            if (x2 <= x1 || y2 <= y1 || x1 < 0 || y1 < 0) continue;
            
            allDetections.add(new Detection(x1, y1, x2, y2, conf, 0));
        }
        
        return applyNMS(allDetections);
    }
    
    private List<Detection> applyNMS(List<Detection> detections) {
        if (detections.isEmpty()) return detections;
        
        Collections.sort(detections, (a, b) -> Float.compare(b.confidence, a.confidence));
        
        for (int i = 0; i < detections.size(); i++) {
            suppressedFlags[i] = false;
        }
        
        List<Detection> result = new ArrayList<>();
        
        for (int i = 0; i < detections.size(); i++) {
            if (suppressedFlags[i]) continue;
            
            Detection current = detections.get(i);
            result.add(current);
            
            float areaA = current.area;
            
            for (int j = i + 1; j < detections.size(); j++) {
                if (suppressedFlags[j]) continue;
                
                Detection other = detections.get(j);
                
                if (current.x2 < other.x1 || other.x2 < current.x1 ||
                    current.y2 < other.y1 || other.y2 < current.y1) {
                    continue;
                }
                
                float interX1 = Math.max(current.x1, other.x1);
                float interY1 = Math.max(current.y1, other.y1);
                float interX2 = Math.min(current.x2, other.x2);
                float interY2 = Math.min(current.y2, other.y2);
                
                float interArea = (interX2 - interX1) * (interY2 - interY1);
                
                if (interArea <= 0) continue;
                
                float unionArea = areaA + other.area - interArea;
                float iou = interArea / unionArea;
                
                if (iou > IOU_THRESHOLD) {
                    suppressedFlags[j] = true;
                }
            }
        }
        
        return result;
    }
    
    private void updateAdaptiveThreshold(List<Detection> detections) {
        int count = detections.size();
        if (count > 20) {
            adaptiveConfThreshold = Math.min(0.4f, adaptiveConfThreshold + 0.01f);
        } else if (count < 5) {
            adaptiveConfThreshold = Math.max(CONF_THRESHOLD, adaptiveConfThreshold - 0.01f);
        }
    }
    
    public void close() {
        try {
            if (session != null) session.close();
            if (env != null) env.close();
        } catch (Exception e) {
            Log.e(TAG, "Error closing", e);
        }
    }
}


================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/java/com/animedetector/DetectionSmoother.java
================================================================================

package com.animedetector;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Queue;

public class DetectionSmoother {
    private final int windowSize;
    private final Queue<OptimizedAnimeDetector.DetectionResult> history;
    private final float POSITION_THRESHOLD_SQ = 50f * 50f;
    
    private static final int GRID_SIZE = 32;
    private final Map<Integer, List<OptimizedAnimeDetector.Detection>> spatialGrid;
    private final List<OptimizedAnimeDetector.Detection> reusableList;
    
    public DetectionSmoother(int windowSize) {
        this.windowSize = windowSize;
        this.history = new LinkedList<>();
        this.spatialGrid = new HashMap<>();
        this.reusableList = new ArrayList<>();
    }
    
    public synchronized OptimizedAnimeDetector.DetectionResult smooth(
            OptimizedAnimeDetector.DetectionResult newResult) {
        
        history.offer(newResult);
        
        while (history.size() > windowSize) {
            history.poll();
        }
        
        if (history.size() < 2) {
            return newResult;
        }
        
        List<OptimizedAnimeDetector.Detection> smoothed = mergeDetections(newResult);
        
        return new OptimizedAnimeDetector.DetectionResult(
            smoothed, newResult.imageWidth, newResult.imageHeight
        );
    }
    
    private List<OptimizedAnimeDetector.Detection> mergeDetections(
            OptimizedAnimeDetector.DetectionResult latest) {
        
        List<OptimizedAnimeDetector.Detection> merged = new ArrayList<>();
        
        buildSpatialGrid(latest.imageWidth, latest.imageHeight);
        
        int minOccurrences = Math.max(1, windowSize / 2);
        
        for (OptimizedAnimeDetector.Detection current : latest.detections) {
            reusableList.clear();
            findSimilarInGrid(current, latest, reusableList);
            
            if (reusableList.size() >= minOccurrences) {
                merged.add(averageDetections(reusableList));
            } else if (current.confidence > 0.5f) {
                merged.add(current);
            }
        }
        
        return merged;
    }
    
    private void buildSpatialGrid(int imageWidth, int imageHeight) {
        spatialGrid.clear();
        
        float cellWidth = (float) imageWidth / GRID_SIZE;
        float cellHeight = (float) imageHeight / GRID_SIZE;
        
        for (OptimizedAnimeDetector.DetectionResult result : history) {
            for (OptimizedAnimeDetector.Detection det : result.detections) {
                int gridX = Math.max(0, Math.min(GRID_SIZE - 1, 
                    (int) (det.centerX / cellWidth)));
                int gridY = Math.max(0, Math.min(GRID_SIZE - 1, 
                    (int) (det.centerY / cellHeight)));
                
                int key = gridY * GRID_SIZE + gridX;
                spatialGrid.computeIfAbsent(key, k -> new ArrayList<>()).add(det);
            }
        }
    }
    
    private void findSimilarInGrid(
            OptimizedAnimeDetector.Detection target,
            OptimizedAnimeDetector.DetectionResult latest,
            List<OptimizedAnimeDetector.Detection> output) {
        
        output.add(target);
        
        float cellWidth = (float) latest.imageWidth / GRID_SIZE;
        float cellHeight = (float) latest.imageHeight / GRID_SIZE;
        
        int gridX = Math.max(0, Math.min(GRID_SIZE - 1, 
            (int) (target.centerX / cellWidth)));
        int gridY = Math.max(0, Math.min(GRID_SIZE - 1, 
            (int) (target.centerY / cellHeight)));
        
        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                int nx = gridX + dx;
                int ny = gridY + dy;
                
                if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) continue;
                
                int key = ny * GRID_SIZE + nx;
                List<OptimizedAnimeDetector.Detection> cell = spatialGrid.get(key);
                
                if (cell == null) continue;
                
                for (OptimizedAnimeDetector.Detection candidate : cell) {
                    float dx2 = candidate.centerX - target.centerX;
                    float dy2 = candidate.centerY - target.centerY;
                    float distSq = dx2 * dx2 + dy2 * dy2;
                    
                    if (distSq < POSITION_THRESHOLD_SQ) {
                        output.add(candidate);
                        if (output.size() >= windowSize) return;
                    }
                }
            }
        }
    }
    
    private OptimizedAnimeDetector.Detection averageDetections(
            List<OptimizedAnimeDetector.Detection> detections) {
        
        float x1 = 0, y1 = 0, x2 = 0, y2 = 0, conf = 0;
        float invCount = 1.0f / detections.size();
        
        for (OptimizedAnimeDetector.Detection det : detections) {
            x1 += det.x1;
            y1 += det.y1;
            x2 += det.x2;
            y2 += det.y2;
            conf += det.confidence;
        }
        
        return new OptimizedAnimeDetector.Detection(
            x1 * invCount, y1 * invCount,
            x2 * invCount, y2 * invCount,
            conf * invCount, 0
        );
    }
    
    public synchronized void clear() {
        history.clear();
        spatialGrid.clear();
    }
}

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/res/layout/activity_main.xml
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="24dp"
    android:gravity="center"
    android:background="#000000">

    <ImageView
        android:layout_width="120dp"
        android:layout_height="120dp"
        android:src="@android:drawable/ic_menu_view"
        android:tint="#00FF00"
        android:layout_marginBottom="32dp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Anime Detector"
        android:textSize="28sp"
        android:textColor="#FFFFFF"
        android:textStyle="bold"
        android:layout_marginBottom="8dp"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Screen Overlay Edition"
        android:textSize="16sp"
        android:textColor="#00FF00"
        android:layout_marginBottom="48dp"/>

    <TextView
        android:id="@+id/tvStatus"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="âšª Ù…ØªÙˆÙ‚Ù"
        android:textSize="18sp"
        android:textColor="#FFFFFF"
        android:layout_marginBottom="32dp"
        android:padding="12dp"
        android:background="#222222"/>

    <Button
        android:id="@+id/btnStart"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="â–¶ï¸ Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù"
        android:textSize="18sp"
        android:padding="16dp"
        android:backgroundTint="#00AA00"
        android:textColor="#FFFFFF"
        android:layout_marginBottom="16dp"/>

    <Button
        android:id="@+id/btnStop"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ´Ù"
        android:textSize="18sp"
        android:padding="16dp"
        android:backgroundTint="#AA0000"
        android:textColor="#FFFFFF"
        android:enabled="false"/>

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="â„¹ï¸ ÙŠØ¹Ù…Ù„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ ÙÙˆÙ‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰ ÙˆÙŠÙƒØ´Ù Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø£Ù†Ù…ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹"
        android:textSize="12sp"
        android:textColor="#888888"
        android:gravity="center"
        android:layout_marginTop="32dp"
        android:padding="8dp"/>

</LinearLayout>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/res/layout/overlay_layout.xml
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<FrameLayout 
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ImageView
        android:id="@+id/overlayImage"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:scaleType="fitXY" />

</FrameLayout>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/res/values/strings.xml
================================================================================

<resources>
    <string name="app_name">Anime Detector</string>
</resources>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/res/values/themes.xml
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.AnimeDetector" parent="Theme.MaterialComponents.DayNight.NoActionBar">
        <item name="colorPrimary">#000000</item>
        <item name="colorPrimaryDark">#000000</item>
        <item name="colorAccent">#00FF00</item>
        <item name="android:statusBarColor">#000000</item>
        <item name="android:navigationBarColor">#000000</item>
    </style>
</resources>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/res/values/colors.xml
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="black">#FF000000</color>
    <color name="white">#FFFFFFFF</color>
    <color name="green">#FF00FF00</color>
</resources>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/res/xml/backup_rules.xml
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <exclude domain="sharedpref" path="." />
</full-backup-content>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/src/main/res/xml/data_extraction_rules.xml
================================================================================

<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <exclude domain="sharedpref" path="." />
    </cloud-backup>
</data-extraction-rules>

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/build.gradle
================================================================================

plugins {
    id 'com.android.application'
}

android {
    namespace 'com.animedetector'
    compileSdk 34
    
    defaultConfig {
        applicationId "com.animedetector"
        minSdk 24
        targetSdk 34
        versionCode 1
        versionName "1.0-overlay"
        
        ndk {
            abiFilters 'armeabi-v7a', 'arm64-v8a'
        }
    }
    
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 
                'proguard-rules.pro'
        }
    }
    
    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    
    buildFeatures {
        viewBinding true
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.4'
    
    // ONNX Runtime
    implementation 'com.microsoft.onnxruntime:onnxruntime-android:1.17.0'
}

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: app/proguard-rules.pro
================================================================================

# ONNX Runtime
-keep class ai.onnxruntime.** { *; }
-dontwarn ai.onnxruntime.**

# Detection classes
-keep class com.animedetector.OptimizedAnimeDetector$Detection { *; }
-keep class com.animedetector.OptimizedAnimeDetector$DetectionResult { *; }

-optimizationpasses 5
-dontusemixedcaseclassnames

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: build.gradle (Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø´Ø±ÙˆØ¹)
================================================================================

buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:8.2.0'
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: settings.gradle
================================================================================

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "AnimeDetector"
include ':app'

================================================================================
ğŸ“ Ø§Ù„Ù…Ø³Ø§Ø±: gradle.properties
================================================================================

org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
org.gradle.parallel=true
org.gradle.caching=true

android.useAndroidX=true
android.enableJetifier=true

kotlin.code.style=official

================================================================================
                        ğŸ“– Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ù…Ù„
================================================================================

## ğŸš€ Ø§Ù„ØªØ´ØºÙŠÙ„

1. **Ø§ÙØªØ­ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚**
   - Ø³ÙŠØ·Ù„Ø¨ Ù…Ù†Ùƒ ØµÙ„Ø§Ø­ÙŠØªÙŠÙ†:
     âœ… Ø§Ù„Ø¹Ø±Ø¶ ÙÙˆÙ‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø§Ù„Ø£Ø®Ø±Ù‰
     âœ… Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„Ø´Ø§Ø´Ø©

2. **Ø§Ø¶ØºØ· "â–¶ï¸ Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ´Ù"**
   - Ø³ÙŠØ¨Ø¯Ø£ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø¨Ø§Ù„Ø¹Ù…Ù„ ÙƒÙ€ overlay ÙÙˆÙ‚ Ø§Ù„Ø´Ø§Ø´Ø©

3. **Ø§Ø³ØªØ®Ø¯Ù… Ø£ÙŠ ØªØ·Ø¨ÙŠÙ‚**
   - Ø´ØºÙ‘Ù„ YouTube, Netflix, Ø£ÙŠ Ø´ÙŠØ¡
   - Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ø³ÙŠÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ ÙˆÙŠØ¹ØªÙ…Ù‡!

4. **Ù„Ù„Ø¥ÙŠÙ‚Ø§Ù**
   - Ø§ÙØªØ­ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰
   - Ø§Ø¶ØºØ· "â¸ï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ÙƒØ´Ù"

## âš™ï¸ Ø§Ù„ØªØ®ØµÙŠØµ

### ØªØºÙŠÙŠØ± Ù…Ø¹Ø¯Ù„ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©:
```java
// ÙÙŠ OverlayService.java
private static final int FRAME_SKIP = 3; // Ø¹Ø¯Ù‘Ù„ Ù‡Ù†Ø§

// Ø£Ø³Ø±Ø¹ (ÙŠØ³ØªÙ‡Ù„Ùƒ Ø¨Ø·Ø§Ø±ÙŠØ© Ø£ÙƒØ«Ø±):
FRAME_SKIP = 1;

// Ø£Ø¨Ø·Ø£ (ÙŠÙˆÙØ± Ø¨Ø·Ø§Ø±ÙŠØ©):
FRAME_SKIP = 5;
```

### ØªØºÙŠÙŠØ± Ù„ÙˆÙ† Ø§Ù„ØªØ¹ØªÙŠÙ…:
```java
// ÙÙŠ OverlayService.java, Ø¯Ø§Ø®Ù„ updateOverlay()
paint.setColor(Color.argb(220, 0, 0, 0)); // Ø£Ø³ÙˆØ¯

// Ø£Ø­Ù…Ø± Ø´ÙØ§Ù:
paint.setColor(Color.argb(150, 255, 0, 0));

// Ø£Ø²Ø±Ù‚:
paint.setColor(Color.argb(200, 0, 0, 255));
```

### ØªØºÙŠÙŠØ± Ø§Ù„Ø¯Ù‚Ø©:
```java
// ÙÙŠ OptimizedAnimeDetector.java
private static final int INPUT_SIZE = 640;

// Ø¯Ù‚Ø© Ø£Ø¹Ù„Ù‰ (Ø£Ø¨Ø·Ø£):
INPUT_SIZE = 768;

// Ø¯Ù‚Ø© Ø£Ù‚Ù„ (Ø£Ø³Ø±Ø¹):
INPUT_SIZE = 416;
```

## ğŸ› Ø­Ù„ Ø§Ù„Ù…Ø´Ø§ÙƒÙ„

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù„Ø§ ÙŠØ¸Ù‡Ø± overlay
**Ø§Ù„Ø­Ù„:**
1. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª:
   - Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª â†’ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª â†’ Anime Detector
   - ØªØ£ÙƒØ¯ Ù…Ù† ØªÙØ¹ÙŠÙ„ "Ø§Ù„Ø¹Ø±Ø¶ ÙÙˆÙ‚ ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø£Ø®Ø±Ù‰"

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Ø§Ù„Ø´Ø§Ø´Ø© Ø³ÙˆØ¯Ø§Ø¡
**Ø§Ù„Ø­Ù„:**
1. ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ù†Ø­ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„Ø´Ø§Ø´Ø©
2. Ø£Ø¹Ø¯ ØªØ´ØºÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Ø¨Ø·Ø¡ ÙÙŠ Ø§Ù„Ø£Ø¯Ø§Ø¡
**Ø§Ù„Ø­Ù„:**
1. Ø²ÙŠØ§Ø¯Ø© FRAME_SKIP Ø¥Ù„Ù‰ 5 Ø£Ùˆ Ø£ÙƒØ«Ø±
2. ØªÙ‚Ù„ÙŠÙ„ INPUT_SIZE Ø¥Ù„Ù‰ 416
3. Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚Ø§Øª Ø§Ù„Ø®Ù„ÙÙŠØ©

### Ø§Ù„Ù…Ø´ÙƒÙ„Ø©: Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø¨Ø·Ø§Ø±ÙŠØ© Ø¹Ø§Ù„ÙŠ
**Ø§Ù„Ø­Ù„:**
1. FRAME_SKIP = 7 (ÙƒÙ„ 8 Ø¥Ø·Ø§Ø±Ø§Øª)
2. Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© ÙÙ‚Ø·

## ğŸ“Š Ø§Ù„Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù…ØªÙˆÙ‚Ø¹

| Ø§Ù„Ø¬Ù‡Ø§Ø² | FPS | Ø§Ø³ØªÙ‡Ù„Ø§Ùƒ Ø§Ù„Ø¨Ø·Ø§Ø±ÙŠØ© |
|--------|-----|-------------------|
| Ù‚ÙˆÙŠ (8+ cores) | 25-30 | Ù…ØªÙˆØ³Ø· |
| Ù…ØªÙˆØ³Ø· (4-6 cores) | 15-20 | Ù…ØªÙˆØ³Ø·-Ø¹Ø§Ù„ÙŠ |
| Ø¶Ø¹ÙŠÙ (2-4 cores) | 8-12 | Ø¹Ø§Ù„ÙŠ |

## ğŸ”’ Ø§Ù„Ø®ØµÙˆØµÙŠØ©

- âŒ Ù„Ø§ ÙŠØªÙ… Ø­ÙØ¸ Ø£ÙŠ Ù„Ù‚Ø·Ø§Øª Ø´Ø§Ø´Ø©
- âŒ Ù„Ø§ ÙŠØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø£ÙŠ Ø¨ÙŠØ§Ù†Ø§Øª
- âœ… ÙƒÙ„ Ø´ÙŠØ¡ Ù…Ø­Ù„ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù‡Ø§Ø²
- âœ… ÙŠØªÙˆÙ‚Ù Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚

## âœ¨ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø©

1. **Ø§Ù„Ù…ÙˆØ¯ÙŠÙ„**: ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¶Ø¹ `anime_detector.onnx` ÙÙŠ `app/src/main/assets/`

2. **Android 10+**: ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ø£ÙØ¶Ù„ Ø¹Ù„Ù‰ Android 10 ÙˆØ£Ø­Ø¯Ø«

3. **Ø§Ù„Ø£Ø¯Ø§Ø¡**: Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ Ù…Ø­Ø³Ù‘Ù† Ù„ÙƒÙ† Ù‚Ø¯ ÙŠØ³ØªÙ‡Ù„Ùƒ Ø¨Ø·Ø§Ø±ÙŠØ© Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©

4. **Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…**: Ø§Ø³ØªØ®Ø¯Ù…Ù‡ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø© ÙÙ‚Ø· Ø«Ù… Ø£ÙˆÙ‚ÙÙ‡ Ù„Ù„Ø­ÙØ§Ø¸ Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø·Ø§Ø±ÙŠØ©

================================================================================
                        ğŸ¯ Ø§Ù„Ø®Ù„Ø§ØµØ©
================================================================================

ØªØ·Ø¨ÙŠÙ‚ Ø¬Ø§Ù‡Ø² 100% ÙŠØ¹Ù…Ù„ ÙƒÙ€ overlay ÙÙˆÙ‚ Ø§Ù„Ø´Ø§Ø´Ø©:

âœ… ÙŠÙ„ØªÙ‚Ø· Ø§Ù„Ø´Ø§Ø´Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
âœ… ÙŠÙƒØ´Ù Ø§Ù„Ø£Ù†Ù…ÙŠ ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ
âœ… ÙŠØ¹Ø±Ø¶ overlay ØªØ¹ØªÙŠÙ… ÙÙˆÙ‚ Ø§Ù„Ø´Ø®ØµÙŠØ§Øª
âœ… ÙŠØ¹Ù…Ù„ Ù…Ø¹ Ø£ÙŠ ØªØ·Ø¨ÙŠÙ‚ (YouTube, Netflix, etc)
âœ… Ù…Ø­Ø³Ù‘Ù† Ù„Ù„Ø£Ø¯Ø§Ø¡ ÙˆØ§Ù„Ø°Ø§ÙƒØ±Ø©
âœ… Ù„Ø§ ÙŠØ­ØªØ§Ø¬ ÙƒØ§Ù…ÙŠØ±Ø§ Ø¥Ø·Ù„Ø§Ù‚Ø§Ù‹

ÙÙ‚Ø· Ø§Ù†Ø³Ø® Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ ÙˆÙ„ØµÙ‚Ù‡Ø§ ÙˆØ´ØºÙ‘Ù„! ğŸš€

================================================================================
